<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ‹‰å¯† Rummikub (å…¨åŸŸç ´å†°ç‰ˆ)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@700&family=Noto+Sans+TC:wght@400;700&display=swap');
        
        body {
            font-family: 'Noto Sans TC', sans-serif;
            background-color: #1a202c;
            overflow: hidden;
            color: #333;
            user-select: none;
            height: 100vh;
            width: 100vw;
        }

        *:focus {
            outline: none;
        }

        .game-focusable:focus, .tile:focus {
            box-shadow: 0 0 0 4px #fbbf24, 0 0 15px rgba(251, 191, 36, 0.6) !important;
            transform: scale(1.1) translateY(-5px) !important;
            z-index: 100 !important;
            border-color: #f59e0b !important;
        }

        .tile {
            width: 44px;
            height: 62px;
            background: linear-gradient(145deg, #fffef0, #f0e6d2);
            border-radius: 6px;
            box-shadow: 
                1px 1px 0px #bbb, 
                2px 2px 3px rgba(0,0,0,0.3),
                inset 0 0 2px rgba(255,255,255,0.8);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            font-family: 'Roboto Mono', monospace;
            font-weight: 700;
            font-size: 1.6rem;
            cursor: pointer;
            position: relative;
            transition: transform 0.1s, box-shadow 0.1s;
            border: 1px solid #d1d5db;
        }

        .tile span {
            text-shadow: 0px 1px 0px rgba(255,255,255,0.9);
        }

        .tile.selected {
            transform: translateY(-14px);
            box-shadow: 
                0 0 0 3px #f59e0b,
                0 15px 20px -5px rgba(0, 0, 0, 0.5);
            z-index: 50;
            border-color: #f59e0b;
        }
        
        .tile.selected::after {
            content: 'âœ“';
            position: absolute;
            top: -10px;
            right: -10px;
            background: #d97706;
            color: white;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            font-size: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 2px solid white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        .tile.joker {
            font-size: 1.8rem;
        }

        .color-red { color: #d32f2f; }
        .color-blue { color: #1565c0; }
        .color-black { color: #212121; }
        .color-orange { color: #ea580c; } 

        #board-container {
            background-color: #2f5242;
            background-image: 
                linear-gradient(rgba(255,255,255,0.03) 1px, transparent 1px),
                linear-gradient(90deg, rgba(255,255,255,0.03) 1px, transparent 1px);
            background-size: 20px 20px;
            box-shadow: inset 0 0 30px rgba(0,0,0,0.6);
        }

        .board-group {
            min-height: 80px;
            background-color: rgba(0, 0, 0, 0.2);
            border-radius: 12px;
            padding: 8px 12px;
            padding-top: 24px;
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
            align-items: center;
            border: 2px solid rgba(255,255,255,0.05);
            transition: all 0.2s;
            position: relative;
        }
        
        .board-group::before {
            content: attr(data-label);
            position: absolute;
            top: 4px;
            left: 8px;
            font-size: 0.75rem;
            color: rgba(255,255,255,0.6);
            font-weight: bold;
            letter-spacing: 0.5px;
        }

        .board-group.invalid {
            background-color: rgba(239, 68, 68, 0.2);
            border-color: #ef4444;
            animation: pulse-red 1s infinite;
        }

        @keyframes pulse-red {
            0%, 100% { border-color: #ef4444; }
            50% { border-color: #fee2e2; }
        }

        #hand-area {
            min-height: 140px;
            background: #4a342e;
            border-top: 6px solid #2d1f1b;
            box-shadow: 0 -4px 15px rgba(0,0,0,0.5);
            position: relative;
        }

        #hand-area::before {
            content: "";
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background-image: repeating-linear-gradient(45deg, rgba(255,255,255,0.02) 0px, rgba(255,255,255,0.02) 1px, transparent 1px, transparent 10px);
            pointer-events: none;
        }

        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border-width: 0;
        }

        .opponent-card {
            width: 22px;
            height: 32px;
            background: #2563eb;
            border-radius: 3px;
            border: 1px solid #60a5fa;
            box-shadow: 1px 1px 2px rgba(0,0,0,0.4);
            margin-right: -14px;
        }
        .opponent-card:last-child { margin-right: 0; }

        .btn-glass {
            backdrop-filter: blur(4px);
            transition: all 0.1s;
        }
        .btn-glass:active { transform: translateY(1px); }
        
        .kbd-hint {
            font-size: 0.7em;
            opacity: 0.7;
            margin-left: 4px;
            background: rgba(0,0,0,0.1);
            padding: 1px 4px;
            border-radius: 3px;
        }
    </style>
</head>
<body class="flex flex-col text-gray-800">

    <header class="bg-gray-100 shadow-lg p-2 flex flex-col gap-2 z-20 border-b border-gray-300 shrink-0" role="banner">
        <div class="flex justify-between items-center px-2">
            <h1 class="text-xl font-black text-gray-800 flex items-center gap-2 tracking-tight">
                <span class="text-orange-600 text-2xl">Rummikub</span>
            </h1>
            <div class="text-xs text-gray-600 bg-white px-3 py-1 rounded-full shadow-inner border border-gray-200 font-bold">
                ç‰Œåº«: <span id="deck-count" class="text-blue-600">0</span>
            </div>
        </div>
        
        <div class="flex justify-center gap-3 text-xs md:text-sm">
            <div id="p2-status" class="flex flex-col items-center bg-white p-2 rounded shadow-sm opacity-70 w-24 transition-all">
                <span class="font-bold text-gray-600 mb-1">é›»è…¦ P2</span>
                <div class="flex justify-center w-full px-2 overflow-hidden h-6" id="p2-cards"></div>
                <span id="p2-count" class="mt-1 text-gray-400 font-mono text-xs">14</span>
            </div>
            <div id="p3-status" class="flex flex-col items-center bg-white p-2 rounded shadow-sm opacity-70 w-24 transition-all">
                <span class="font-bold text-gray-600 mb-1">é›»è…¦ P3</span>
                <div class="flex justify-center w-full px-2 overflow-hidden h-6" id="p3-cards"></div>
                <span id="p3-count" class="mt-1 text-gray-400 font-mono text-xs">14</span>
            </div>
            <div id="p4-status" class="flex flex-col items-center bg-white p-2 rounded shadow-sm opacity-70 w-24 transition-all">
                <span class="font-bold text-gray-600 mb-1">é›»è…¦ P4</span>
                <div class="flex justify-center w-full px-2 overflow-hidden h-6" id="p4-cards"></div>
                <span id="p4-count" class="mt-1 text-gray-400 font-mono text-xs">14</span>
            </div>
        </div>

        <div id="turn-indicator" aria-live="polite" class="mx-auto px-6 py-1.5 bg-blue-600 text-white rounded-full shadow-md text-sm font-bold tracking-wide transition-colors">
            éŠæˆ²æº–å‚™ä¸­...
        </div>
        <!-- é¡¯ç¤ºå…¨åŸŸç ´å†°ç‹€æ…‹ -->
        <div id="ice-status" class="text-center text-xs text-gray-500 font-mono mt-1">
            å°šæœªç ´å†° (éœ€ 30 åˆ†)
        </div>
    </header>

    <main id="board-container" class="flex-1 overflow-y-auto p-4 space-y-6 scroll-smooth relative" role="main" aria-label="éŠæˆ²æ¡Œé¢">
        <div class="flex justify-between items-center mb-2 sticky top-0 z-10 pointer-events-none">
            <div class="pointer-events-auto flex gap-2">
                <button onclick="game.readBoard()" 
                        onmouseenter="speaker.speak('æœ—è®€æ¡Œé¢ï¼Œå¿«æ·éµ D', true)"
                        onfocus="speaker.speak('æœ—è®€æ¡Œé¢ï¼Œå¿«æ·éµ D', true)"
                        class="game-focusable btn-glass bg-white/90 hover:bg-white text-gray-800 px-3 py-1.5 rounded-lg text-xs font-bold shadow-md border border-white/50" data-zone="top-nav">
                    ğŸ”Š æœ—è®€ <span class="kbd-hint">D</span>
                </button>
            </div>
            <div class="pointer-events-auto">
                <button onclick="game.clearSelection()" 
                        onmouseenter="speaker.speak('æ¸…é™¤é¸å–ï¼Œå¿«æ·éµ Esc', true)"
                        onfocus="speaker.speak('æ¸…é™¤é¸å–ï¼Œå¿«æ·éµ Esc', true)"
                        class="game-focusable btn-glass bg-red-500/90 hover:bg-red-500 text-white px-3 py-1.5 rounded-lg text-xs font-bold shadow-md border border-red-400" data-zone="top-nav">
                    âœ• æ¸…é™¤é¸å– <span class="kbd-hint">Esc</span>
                </button>
            </div>
        </div>

        <div id="board-groups" class="flex flex-wrap content-start gap-4 pb-24 min-h-[200px]">
            <!-- æ¡Œé¢å…§å®¹ -->
        </div>
        
        <button id="new-group-zone" 
            class="game-focusable w-full border-2 border-dashed border-white/30 rounded-2xl p-6 flex flex-col justify-center items-center text-white/40 font-bold hover:bg-white/5 hover:border-white/60 hover:text-white transition-all focus:bg-white/10 focus:border-yellow-400"
            onclick="game.handleAreaClick(-1)"
            onmouseenter="speaker.speak('å»ºç«‹æ–°ç‰Œçµ„ï¼Œå¿«æ·éµ N', true)"
            onfocus="speaker.speak('å»ºç«‹æ–°ç‰Œçµ„ï¼Œå¿«æ·éµ N', true)"
            data-zone="board-action"
            aria-label="å»ºç«‹æ–°ç‰Œçµ„ (å¿«æ·éµ N)">
            <span class="text-4xl mb-2 opacity-50">+</span> 
            <span class="tracking-widest">å»ºç«‹æ–°ç‰Œçµ„ <span class="text-xs bg-white/10 px-2 py-0.5 rounded ml-2">N</span></span>
        </button>
    </main>

    <div id="live-announcer" class="sr-only" aria-live="assertive"></div>
    
    <div id="message-toast" class="fixed top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 bg-gray-900/95 backdrop-blur-md text-white px-8 py-5 rounded-2xl shadow-2xl hidden z-50 transition-all text-lg font-bold text-center border border-gray-700 min-w-[280px]">
        æç¤ºè¨Šæ¯
    </div>

    <footer class="z-20 flex flex-col shadow-[0_-10px_40px_rgba(0,0,0,0.5)] shrink-0" role="region" aria-label="ç©å®¶æ“ä½œå€">
        <div class="flex justify-between items-center px-4 py-2 bg-gray-800 border-t border-gray-700 text-sm overflow-x-auto">
            <div class="flex gap-2" role="group" aria-label="æ•´ç†æ‰‹ç‰Œ">
                <button onclick="game.sortHand('number')" 
                        onmouseenter="speaker.speak('æŒ‰æ•¸å­—æ’åºï¼Œå¿«æ·éµ 1', true)"
                        onfocus="speaker.speak('æŒ‰æ•¸å­—æ’åºï¼Œå¿«æ·éµ 1', true)"
                        class="game-focusable btn-glass px-3 py-1.5 bg-gray-700 text-gray-200 border border-gray-600 rounded hover:bg-gray-600 text-xs font-bold" data-zone="actions" title="å¿«æ·éµ: 1">æ•¸å­— <span class="kbd-hint">1</span></button>
                <button onclick="game.sortHand('color')" 
                        onmouseenter="speaker.speak('æŒ‰é¡è‰²æ’åºï¼Œå¿«æ·éµ 2', true)"
                        onfocus="speaker.speak('æŒ‰é¡è‰²æ’åºï¼Œå¿«æ·éµ 2', true)"
                        class="game-focusable btn-glass px-3 py-1.5 bg-gray-700 text-gray-200 border border-gray-600 rounded hover:bg-gray-600 text-xs font-bold" data-zone="actions" title="å¿«æ·éµ: 2">é¡è‰² <span class="kbd-hint">2</span></button>
                <button onclick="game.readHand()" 
                        onmouseenter="speaker.speak('æœ—è®€æ‰‹ç‰Œï¼Œå¿«æ·éµ A', true)"
                        onfocus="speaker.speak('æœ—è®€æ‰‹ç‰Œï¼Œå¿«æ·éµ A', true)"
                        class="game-focusable btn-glass px-3 py-1.5 bg-purple-900/50 text-purple-200 border border-purple-700 rounded hover:bg-purple-800/50 text-xs font-bold" data-zone="actions" title="å¿«æ·éµ: A">è®€ç‰Œ <span class="kbd-hint">A</span></button>
            </div>
            <div class="flex gap-2 ml-4" role="group" aria-label="å›åˆæ“ä½œ">
                <button onclick="game.resetTurn()" 
                        onmouseenter="speaker.speak('é‚„åŸå›åˆï¼Œå¿«æ·éµ R', true)"
                        onfocus="speaker.speak('é‚„åŸå›åˆï¼Œå¿«æ·éµ R', true)"
                        class="game-focusable btn-glass px-3 py-1.5 bg-yellow-600 text-white border border-yellow-700 rounded hover:bg-yellow-500 font-bold text-xs shadow" data-zone="actions" title="å¿«æ·éµ: R">é‚„åŸ <span class="kbd-hint">R</span></button>
                <button id="btn-draw" onclick="game.drawCard()" 
                        onmouseenter="speaker.speak('æŠ½ç‰Œæˆ–è·³éï¼Œå¿«æ·éµ P', true)"
                        onfocus="speaker.speak('æŠ½ç‰Œæˆ–è·³éï¼Œå¿«æ·éµ P', true)"
                        class="game-focusable btn-glass px-4 py-1.5 bg-gray-200 text-gray-800 border border-gray-300 rounded hover:bg-white font-bold text-xs shadow" data-zone="actions" title="å¿«æ·éµ: P">æŠ½ç‰Œ/Pass <span class="kbd-hint">P</span></button>
                <button id="btn-submit" onclick="game.submitTurn()" 
                        onmouseenter="speaker.speak('ç¢ºèªå‡ºç‰Œï¼Œå¿«æ·éµ C', true)"
                        onfocus="speaker.speak('ç¢ºèªå‡ºç‰Œï¼Œå¿«æ·éµ C', true)"
                        class="game-focusable btn-glass px-6 py-1.5 bg-blue-600 text-white border border-blue-500 rounded hover:bg-blue-500 font-bold shadow-lg text-sm tracking-wide" data-zone="actions" title="å¿«æ·éµ: C">ç¢ºèªå‡ºç‰Œ <span class="kbd-hint">C</span></button>
            </div>
        </div>

        <div id="hand-area" class="p-4 flex flex-wrap gap-2 justify-center items-start overflow-x-auto overflow-y-hidden content-start" 
             role="region" aria-label="ä½ çš„æ‰‹ç‰Œ">
            <!-- æ‰‹ç‰Œå‹•æ…‹ç”Ÿæˆ -->
        </div>
    </footer>

    <div id="victory-modal" role="alertdialog" aria-modal="true" aria-labelledby="winner-title" class="fixed inset-0 bg-black/80 backdrop-blur-sm flex items-center justify-center hidden z-50">
        <div class="bg-white rounded-xl shadow-2xl text-center max-w-md w-full mx-4 overflow-hidden border-4 border-blue-500">
            <div class="bg-blue-600 p-5">
                <h2 id="winner-title" class="text-3xl font-black text-white tracking-widest uppercase drop-shadow-md">GAME OVER</h2>
            </div>
            <div class="p-6 bg-gray-50">
                <p id="winner-text" class="text-2xl text-gray-800 mb-6 font-bold">ç©å®¶ X ç²å‹ï¼</p>
                <div class="bg-white rounded-xl shadow-inner border border-gray-200 p-4 mb-6">
                    <h3 class="text-xs font-bold text-gray-400 mb-3 uppercase tracking-widest border-b pb-2">æœ€çµ‚è¨ˆåˆ†æ¿</h3>
                    <table class="w-full text-sm text-left">
                        <thead class="text-gray-400 text-xs uppercase">
                            <tr>
                                <th class="pb-2 pl-2">ç©å®¶</th>
                                <th class="pb-2 text-right">å‰©é¤˜æ‰‹ç‰Œ</th>
                                <th class="pb-2 text-right pr-2">ç¸½åˆ†</th>
                            </tr>
                        </thead>
                        <tbody id="score-table-body" class="text-gray-700"></tbody>
                    </table>
                </div>
                <button onclick="location.reload()" class="game-focusable w-full bg-blue-600 text-white py-3.5 rounded-xl hover:bg-blue-700 font-bold text-lg shadow-lg transition-transform hover:scale-[1.02] active:scale-95">å†ä¾†ä¸€å±€</button>
            </div>
        </div>
    </div>

    <script>
        const speaker = {
            synth: window.speechSynthesis,
            speak: function(text, priority = false, onEndCallback = null) {
                if (!this.synth) {
                    if(onEndCallback) setTimeout(onEndCallback, 500); 
                    return;
                }
                
                if (priority) {
                    this.synth.cancel();
                }
                
                const utterance = new SpeechSynthesisUtterance(text);
                utterance.lang = 'zh-TW';
                utterance.rate = 2.2; 
                
                if (onEndCallback) {
                    utterance.onend = () => {
                        onEndCallback();
                    };
                    utterance.onerror = (e) => {
                        console.error("Speech Error", e);
                        onEndCallback();
                    };
                }

                this.synth.speak(utterance);
                
                const announcer = document.getElementById('live-announcer');
                if (announcer) announcer.innerText = text;
            }
        };

        const COLORS = ['red', 'blue', 'black', 'orange'];
        const COLOR_NAMES = { 'red': 'ç´…', 'blue': 'è—', 'black': 'é»‘', 'orange': 'æ©˜' };
        const COLOR_CLASSES = { 'red': 'color-red', 'blue': 'color-blue', 'black': 'color-black', 'orange': 'color-orange' };

        function getTileText(tile) {
            if (!tile) return "";
            if (tile.isJoker) return `${COLOR_NAMES[tile.color]}ç¬‘è‡‰`;
            return `${COLOR_NAMES[tile.color]}${tile.number}`;
        }

        class Tile {
            constructor(id, color, number, isJoker = false) {
                this.id = id;
                this.color = color;
                this.number = number;
                this.isJoker = isJoker;
            }
        }

        class RummikubGame {
            constructor() {
                this.deck = [];
                this.players = [
                    { id: 1, type: 'human', hand: [], hasBrokenIce: false, name: 'ä½  (P1)' },
                    { id: 2, type: 'computer', hand: [], hasBrokenIce: false, name: 'é›»è…¦ P2' },
                    { id: 3, type: 'computer', hand: [], hasBrokenIce: false, name: 'é›»è…¦ P3' },
                    { id: 4, type: 'computer', hand: [], hasBrokenIce: false, name: 'é›»è…¦ P4' }
                ];
                this.board = [];
                this.turn = 0;
                this.backupState = null;
                this.selectedTiles = []; 
                this.isProcessingAI = false;
                this.initialOnBoardTileIds = new Set(); 
                this.isGlobalIceBroken = false; // å…¨åŸŸç ´å†°ç‹€æ…‹

                this.initGame();
                this.setupKeyboardShortcuts();
            }

            initGame() {
                this.createDeck();
                this.shuffleDeck();
                this.dealInitialHands();
                this.board = [];
                this.turn = 0; 
                this.isGlobalIceBroken = false;
                this.saveBackup();
                this.render();
                speaker.speak("éŠæˆ²é–‹å§‹", false);
                
                setTimeout(() => {
                    const firstTile = document.querySelector('#hand-area .tile');
                    if (firstTile) firstTile.focus();
                }, 100);
            }

            setupKeyboardShortcuts() {
                document.addEventListener('keydown', (e) => {
                    if (this.players[this.turn].type === 'computer') return;
                    
                    const key = e.key.toLowerCase();
                    
                    if (['arrowup', 'arrowdown', 'arrowleft', 'arrowright'].includes(key)) {
                        e.preventDefault(); 
                        this.handleArrowNavigation(key);
                        return;
                    }

                    if (e.target.tagName === 'INPUT') return;
                    
                    switch(key) {
                        case 's': this.readSelectionStatus(); break;
                        case 'a': this.readHand(); break;
                        case 'd': this.readBoard(); break;
                        case 'escape': this.clearSelection(); break;
                        case '1': this.sortHand('number'); break;
                        case '2': this.sortHand('color'); break;
                        case 'r': this.resetTurn(); break;
                        case 'p': this.drawCard(); break;
                        case 'c': this.submitTurn(); break;
                        case 'n': 
                            if(this.selectedTiles.length > 0) this.handleAreaClick(-1);
                            else { speaker.speak("è«‹å…ˆé¸ç‰Œ", true); this.showMessage("è«‹å…ˆé¸ç‰Œ"); }
                            break;
                    }
                });
            }

            handleArrowNavigation(key) {
                const active = document.activeElement;
                let currentZone = 'unknown';
                if (active.closest('#hand-area')) currentZone = 'hand';
                else if (active.closest('footer')) currentZone = 'actions'; 
                else if (active.closest('#board-container')) {
                    if (active.id === 'new-group-zone') currentZone = 'new-group';
                    else if (active.dataset.zone === 'top-nav') currentZone = 'top-nav';
                    else currentZone = 'board';
                }

                const getElements = (selector) => Array.from(document.querySelectorAll(selector));
                
                if (key === 'arrowright' || key === 'arrowleft') {
                    let groupSelector = '';
                    if (currentZone === 'hand') groupSelector = '#hand-area .tile';
                    else if (currentZone === 'actions') groupSelector = 'footer button.game-focusable';
                    else if (currentZone === 'board') {
                        groupSelector = '#board-groups .tile, #board-groups .board-group[role="button"]';
                    }
                    else if (currentZone === 'top-nav') groupSelector = 'button[data-zone="top-nav"]';
                    
                    if (groupSelector) {
                        const items = getElements(groupSelector);
                        const idx = items.indexOf(active);
                        if (idx !== -1) {
                            const nextIdx = key === 'arrowright' ? idx + 1 : idx - 1;
                            if (items[nextIdx]) items[nextIdx].focus();
                        }
                    }
                } 
                else if (key === 'arrowup' || key === 'arrowdown') {
                    if (key === 'arrowup') {
                        if (currentZone === 'hand') this.focusFirstIn('#new-group-zone, footer button.game-focusable');
                        else if (currentZone === 'actions') this.focusFirstIn('#new-group-zone');
                        else if (currentZone === 'new-group') this.focusLastIn('#board-groups .tile');
                        else if (currentZone === 'board') this.focusFirstIn('button[data-zone="top-nav"]');
                    } 
                    else if (key === 'arrowdown') {
                        if (currentZone === 'top-nav') this.focusFirstIn('#board-groups .tile, #new-group-zone');
                        else if (currentZone === 'board') this.focusFirstIn('#new-group-zone');
                        else if (currentZone === 'new-group') this.focusFirstIn('footer button.game-focusable');
                        else if (currentZone === 'actions') this.focusFirstIn('#hand-area .tile');
                    }
                }
            }

            focusFirstIn(selector) {
                const el = document.querySelector(selector);
                if (el) el.focus();
                else if (selector.includes('board')) { 
                    if (selector.includes('new-group')) document.querySelector('#new-group-zone')?.focus();
                }
            }
            
            focusLastIn(selector) {
                const els = document.querySelectorAll(selector);
                if (els.length > 0) els[els.length - 1].focus();
            }

            readSelectionStatus() {
                if (this.selectedTiles.length > 0) {
                    speaker.speak(`ç›®å‰å·²é¸ ${this.selectedTiles.length} å¼µç‰Œã€‚`, true);
                } else speaker.speak("æœªé¸å–ä»»ä½•ç‰Œ", true);
            }

            createDeck() {
                this.deck = [];
                let idCounter = 0;
                for (let set = 0; set < 2; set++) {
                    for (const color of COLORS) {
                        for (let num = 1; num <= 13; num++) {
                            this.deck.push(new Tile(idCounter++, color, num));
                        }
                    }
                }
                this.deck.push(new Tile(idCounter++, 'red', 0, true));
                this.deck.push(new Tile(idCounter++, 'black', 0, true));
            }

            shuffleDeck() {
                for (let i = this.deck.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [this.deck[i], this.deck[j]] = [this.deck[j], this.deck[i]];
                }
            }

            dealInitialHands() {
                for (let p = 0; p < this.players.length; p++) {
                    for (let i = 0; i < 14; i++) {
                        if (this.deck.length > 0) this.players[p].hand.push(this.deck.pop());
                    }
                    if (this.players[p].type === 'human') this.sortPlayerHand(p, 'number');
                }
            }

            getCurrentPlayer() { return this.players[this.turn]; }

            saveBackup() {
                this.backupState = {
                    hand: JSON.parse(JSON.stringify(this.getCurrentPlayer().hand)),
                    board: JSON.parse(JSON.stringify(this.board)),
                    globalIceBroken: this.isGlobalIceBroken
                };
                
                this.initialOnBoardTileIds.clear();
                this.board.forEach(group => {
                    group.forEach(tile => {
                        this.initialOnBoardTileIds.add(tile.id);
                    });
                });
            }

            resetTurn() {
                if (this.backupState && this.players[this.turn].type === 'human') {
                    this.getCurrentPlayer().hand = JSON.parse(JSON.stringify(this.backupState.hand));
                    this.board = JSON.parse(JSON.stringify(this.backupState.board));
                    this.isGlobalIceBroken = this.backupState.globalIceBroken;
                    this.selectedTiles = [];
                    this.render();
                    speaker.speak("å·²é‚„åŸ", true);
                    this.focusFirstIn('#hand-area .tile'); 
                }
            }
            
            clearSelection() {
                this.selectedTiles = [];
                this.render();
                speaker.speak("å·²æ¸…é™¤é¸å–", true);
            }

            handleTileClick(source, groupIndex, tileIndex, tileObj) {
                if (this.players[this.turn].type === 'computer') return;
                if (source === 'hand' && this.players[this.turn].id !== 1) return;

                const existingIdx = this.selectedTiles.findIndex(s => 
                    s.source === source && 
                    s.groupIndex === groupIndex && 
                    s.tileIndex === tileIndex
                );

                if (existingIdx > -1) {
                    this.selectedTiles.splice(existingIdx, 1);
                } else {
                    this.selectedTiles.push({ source, groupIndex, tileIndex, tileObj });
                    speaker.speak(`${getTileText(tileObj)}`, true);
                }
                this.render();
                
                setTimeout(() => {
                    let selector = '';
                    if (source === 'hand') {
                        const tiles = document.querySelectorAll('#hand-area .tile');
                        if (tiles[tileIndex]) tiles[tileIndex].focus();
                    } else {
                        const groups = document.querySelectorAll('.board-group');
                        if (groups[groupIndex]) {
                            const tiles = groups[groupIndex].querySelectorAll('.tile');
                            if (tiles[tileIndex]) tiles[tileIndex].focus();
                        }
                    }
                }, 0);
            }

            handleAreaClick(targetGroupIndex) {
                if (this.players[this.turn].type === 'computer') return;
                
                if (this.selectedTiles.length === 0) {
                    if (targetGroupIndex !== -1) {
                         const group = this.board[targetGroupIndex];
                         const text = group.map(t => getTileText(t)).join(" ");
                         speaker.speak(`ç¾¤çµ„ ${targetGroupIndex + 1}ï¼š${text}`, true);
                    }
                    return;
                }
                
                try {
                    this.processMove(targetGroupIndex);
                } catch (e) {
                    console.error("Move Error:", e);
                    this.showMessage("æ“ä½œéŒ¯èª¤ï¼Œè«‹é‚„åŸå›åˆ");
                }
            }

            processMove(targetGroupIndex) {
                const groups = {};
                this.selectedTiles.forEach(sel => {
                    const key = sel.source === 'hand' ? 'hand' : `board-${sel.groupIndex}`;
                    if (!groups[key]) groups[key] = [];
                    groups[key].push(sel);
                });

                const tilesToMove = [];
                for (const key in groups) {
                    groups[key].sort((a, b) => b.tileIndex - a.tileIndex);
                    groups[key].forEach(sel => {
                        let tile;
                        if (sel.source === 'hand') {
                            tile = this.players[0].hand.splice(sel.tileIndex, 1)[0];
                        } else {
                            tile = this.board[sel.groupIndex].splice(sel.tileIndex, 1)[0];
                        }
                        if (tile) tilesToMove.push(tile);
                    });
                }
                
                tilesToMove.sort((a, b) => {
                     if (a.isJoker && b.isJoker) return 0;
                     if (a.isJoker) return 1; 
                     if (b.isJoker) return -1;
                     return a.number - b.number;
                });

                if (targetGroupIndex === -1) {
                    this.board.push(tilesToMove);
                    speaker.speak("å»ºç«‹æ–°ç¾¤çµ„", true);
                } else if (targetGroupIndex === 'hand') {
                    this.players[0].hand.push(...tilesToMove);
                    speaker.speak("æ”¶å›æ‰‹ç‰Œ", true);
                } else {
                    this.board[targetGroupIndex].push(...tilesToMove);
                    this.board[targetGroupIndex].sort((a, b) => {
                         if (a.isJoker && b.isJoker) return 0;
                         if (a.isJoker) return 1; 
                         if (b.isJoker) return -1;
                         return a.number - b.number;
                    });
                    speaker.speak(`åŠ å…¥ç¾¤çµ„`, true);
                }

                this.selectedTiles = [];
                this.board = this.board.filter(g => g.length > 0);
                this.render();
                
                setTimeout(() => {
                    if (targetGroupIndex === -1) this.focusLastIn('#board-groups .tile');
                    else if (targetGroupIndex === 'hand') this.focusLastIn('#hand-area .tile');
                }, 50);
            }

            drawCard(isAI = false) {
                if (this.isProcessingAI && !isAI) return;

                if (!isAI) {
                    const isBoardChanged = JSON.stringify(this.board) !== JSON.stringify(this.backupState.board);
                    const isHandChanged = JSON.stringify(this.getCurrentPlayer().hand) !== JSON.stringify(this.backupState.hand);

                    if (isBoardChanged || isHandChanged) {
                        if(!confirm("ç¢ºå®šè¦æ”¾æ£„æœ¬å›åˆå‹•ä½œä¸¦æŠ½ç‰Œå—ï¼Ÿ")) return;
                        this.resetTurn();
                    }
                }

                if (this.deck.length > 0) {
                    const card = this.deck.pop();
                    this.getCurrentPlayer().hand.push(card);
                    if (this.players[this.turn].type === 'human') {
                        speaker.speak(`æŠ½åˆ° ${getTileText(card)}ï¼Œå›åˆçµæŸ`, true);
                        this.nextTurn();
                    } else {
                        const text = `${this.players[this.turn].name} æŠ½ç‰Œ`;
                        speaker.speak(text, false, () => this.nextTurn());
                    }
                } else {
                    if(isAI) {
                        speaker.speak("ç‰Œåº«å·²ç©ºï¼ŒPass", false, () => this.nextTurn());
                    } else {
                        speaker.speak("ç‰Œåº«å·²ç©ºï¼ŒPass", true);
                        this.nextTurn();
                    }
                }
            }

            submitTurn() {
                if (this.isProcessingAI) return;
                
                const invalidGroups = [];
                this.board = this.board.filter(g => g.length > 0);

                for (let i = 0; i < this.board.length; i++) {
                    if (!this.validateGroup(this.board[i])) invalidGroups.push(i);
                }

                if (invalidGroups.length > 0) {
                    speaker.speak(`æœ‰ç‰Œçµ„ä¸ç¬¦åˆè¦å‰‡`, true);
                    this.highlightInvalidGroups(invalidGroups);
                    this.showMessage("æ¡Œé¢æœ‰ä¸åˆæ³•çš„ç‰Œçµ„");
                    return;
                }

                const currentHandSize = this.getCurrentPlayer().hand.length;
                const backupHandSize = this.backupState.hand.length;

                if (currentHandSize >= backupHandSize) {
                    speaker.speak("æ‚¨æ²’æœ‰å‡ºç‰Œ", true);
                    this.showMessage("è«‹å‡ºç‰Œæˆ–é¸æ“‡æŠ½ç‰Œ");
                    return;
                }

                const player = this.getCurrentPlayer();
                
                // === ç ´å†°æª¢æŸ¥ (Global) ===
                if (!this.isGlobalIceBroken) {
                    let totalNewMeldValue = 0;

                    for (let group of this.board) {
                        const containsOld = group.some(t => this.initialOnBoardTileIds.has(t.id));
                        const containsNew = group.some(t => !this.initialOnBoardTileIds.has(t.id));

                        if (containsOld && containsNew) {
                            speaker.speak("ç ´å†°å¤±æ•—ï¼šä¸èƒ½æ¥æ¡Œä¸Šçš„èˆŠç‰Œ", true);
                            this.showMessage("ç ´å†°æ™‚ä¸èƒ½æ¥é¾ (æ··ç”¨äº†èˆŠç‰Œ)");
                            return;
                        }

                        if (!containsOld && containsNew) {
                            totalNewMeldValue += this.calculateGroupValue(group);
                        }
                    }

                    if (totalNewMeldValue < 30) {
                        speaker.speak(`åˆ†æ•¸ä¸è¶³ï¼Œæ–°ç‰Œçµ„åƒ… ${totalNewMeldValue} åˆ†`, true);
                        this.showMessage(`ç ´å†°ç¸½åˆ† ${totalNewMeldValue} / 30`);
                        return;
                    }
                    
                    this.isGlobalIceBroken = true;
                    speaker.speak("ç ´å†°æˆåŠŸï¼æ‰€æœ‰äººçš†å¯å‡ºç‰Œã€‚", true);
                }

                if (currentHandSize === 0) {
                    this.showVictory(player);
                    return;
                }

                speaker.speak("å‡ºç‰ŒæˆåŠŸ", true);
                this.nextTurn();
            }

            nextTurn() {
                this.turn = (this.turn + 1) % this.players.length;
                this.saveBackup();
                this.selectedTiles = []; 
                this.render();

                const player = this.players[this.turn];
                if (player.type === 'computer') {
                    this.isProcessingAI = true;
                    setTimeout(() => this.playAITurn(), 300);
                } else {
                    this.isProcessingAI = false;
                    speaker.speak("è¼ªåˆ°ä½ äº†", false);
                    setTimeout(() => this.focusFirstIn('#hand-area .tile'), 100);
                }
            }

            playAITurn() {
                try {
                    const ai = this.getCurrentPlayer();
                    let movesMade = false;
                    
                    let tempHand = [...ai.hand];
                    let playedTiles = []; 
                    let cardsPlayedThisTurn = []; 

                    const numMap = {};
                    tempHand.forEach(t => {
                        if(!t.isJoker) {
                            if(!numMap[t.number]) numMap[t.number] = [];
                            numMap[t.number].push(t);
                        }
                    });

                    for(let num in numMap) {
                        const group = numMap[num];
                        const uniqueColors = [];
                        const validTiles = [];
                        group.forEach(t => {
                            if(!uniqueColors.includes(t.color)) {
                                uniqueColors.push(t.color);
                                validTiles.push(t);
                            }
                        });
                        if(validTiles.length >= 3) {
                            playedTiles.push([...validTiles]);
                            validTiles.forEach(vt => {
                                const idx = tempHand.findIndex(h => h.id === vt.id);
                                if(idx > -1) tempHand.splice(idx, 1);
                            });
                        }
                    }

                    if (!this.isGlobalIceBroken) {
                        let totalVal = 0;
                        playedTiles.forEach(g => totalVal += this.calculateGroupValue(g));
                        if (totalVal < 30) { this.drawCard(true); return; } 
                        else { this.isGlobalIceBroken = true; }
                    }

                    if (playedTiles.length > 0) {
                        playedTiles.forEach(group => {
                            this.board.push(group);
                            group.forEach(t => {
                                cardsPlayedThisTurn.push(t);
                                const idx = ai.hand.findIndex(h => h.id === t.id);
                                if(idx > -1) ai.hand.splice(idx, 1);
                            });
                        });
                        movesMade = true;
                    }

                    if (this.isGlobalIceBroken) {
                        for (let i = ai.hand.length - 1; i >= 0; i--) {
                            const tile = ai.hand[i];
                            if (tile.isJoker) continue; 
                            for (let g = 0; g < this.board.length; g++) {
                                const group = this.board[g];
                                group.push(tile);
                                if (this.validateGroup(group)) {
                                    group.sort((a,b) => {
                                        if (a.isJoker) return 1; if (b.isJoker) return -1;
                                        return a.number - b.number
                                    });
                                    cardsPlayedThisTurn.push(tile);
                                    ai.hand.splice(i, 1);
                                    movesMade = true;
                                    break; 
                                } else { group.pop(); }
                            }
                        }
                    }

                    if (movesMade) {
                        if (ai.hand.length === 0) {
                            this.showVictory(ai);
                        } else {
                            const playedText = cardsPlayedThisTurn.map(t => getTileText(t)).join("ã€");
                            const speechText = `${ai.name} å‡ºäº†: ${playedText}`;
                            
                            // é—œéµä¿®æ­£: å¿…é ˆç­‰èªéŸ³èªªå®Œæ‰ Next Turn
                            speaker.speak(speechText, false, () => this.nextTurn());
                        }
                    } else {
                        this.drawCard(true);
                    }
                } catch (e) {
                    console.error("AI Error:", e);
                    this.drawCard(true);
                }
            }

            validateGroup(group) {
                if (group.length < 3) return false;
                const jokers = group.filter(t => t.isJoker);
                const tiles = group.filter(t => !t.isJoker);
                if (tiles.length === 0) return true;
                if (this.checkSet(tiles, jokers.length)) return true;
                if (this.checkRun(tiles, jokers.length)) return true;
                return false;
            }

            checkSet(tiles, jokerCount) {
                if(!tiles || tiles.length === 0) return true;
                const baseNum = tiles[0].number;
                const seenColors = new Set();
                for (let t of tiles) {
                    if (t.number !== baseNum) return false;
                    if (seenColors.has(t.color)) return false;
                    seenColors.add(t.color);
                }
                if (tiles.length + jokerCount > 4) return false;
                return true;
            }

            checkRun(tiles, jokerCount) {
                if(!tiles || tiles.length === 0) return true; 
                const baseColor = tiles[0].color;
                for (let t of tiles) if (t.color !== baseColor) return false;
                const sorted = [...tiles].sort((a, b) => a.number - b.number);
                let neededJokers = 0;
                for (let i = 0; i < sorted.length - 1; i++) {
                    const gap = sorted[i+1].number - sorted[i].number - 1;
                    if (gap < 0) return false;
                    neededJokers += gap;
                }
                return neededJokers <= jokerCount;
            }

            calculateGroupValue(group) {
                const jokers = group.filter(t => t.isJoker);
                const tiles = group.filter(t => !t.isJoker);
                if (tiles.length === 0) return 30; 
                let total = 0;
                const isSet = this.checkSet(tiles, 10);
                if (isSet) {
                    const num = tiles[0].number;
                    total = num * group.length;
                } else {
                    const sorted = [...tiles].sort((a,b) => a.number - b.number);
                    total = sorted.reduce((sum, t) => sum + t.number, 0);
                    let usedJokers = 0;
                    for (let i = 0; i < sorted.length - 1; i++) {
                        const gap = sorted[i+1].number - sorted[i].number - 1;
                        for(let k=1; k<=gap; k++) { total += (sorted[i].number + k); usedJokers++; }
                    }
                    let remainingJokers = jokers.length - usedJokers;
                    let lastNum = sorted[sorted.length-1].number;
                    let firstNum = sorted[0].number;
                    while(remainingJokers > 0) {
                        if (lastNum < 13) { lastNum++; total += lastNum; }
                        else if (firstNum > 1) { firstNum--; total += firstNum; }
                        remainingJokers--;
                    }
                }
                return total;
            }

            calculateHandScore(hand) {
                let score = 0;
                hand.forEach(tile => {
                    if (tile.isJoker) score += 30;
                    else score += tile.number;
                });
                return score;
            }

            sortPlayerHand(pIdx, type) {
                const hand = this.players[pIdx].hand;
                if (type === 'number') {
                    hand.sort((a, b) => {
                        if (a.isJoker && b.isJoker) return 0;
                        if (a.isJoker) return 1; if (b.isJoker) return -1;
                        if (a.number === b.number) return COLORS.indexOf(a.color) - COLORS.indexOf(b.color);
                        return a.number - b.number;
                    });
                } else {
                    hand.sort((a, b) => {
                        if (a.isJoker && b.isJoker) return 0;
                        if (a.isJoker) return 1; if (b.isJoker) return -1;
                        if (a.color === b.color) return a.number - b.number;
                        return COLORS.indexOf(a.color) - COLORS.indexOf(b.color);
                    });
                }
                if(pIdx === 0) {
                    this.render();
                    speaker.speak(type === 'number' ? "å·²æŒ‰æ•¸å­—æ’åº" : "å·²æŒ‰é¡è‰²æ’åº", true);
                    this.focusFirstIn('#hand-area .tile');
                }
            }
            sortHand(type) { this.sortPlayerHand(0, type); }

            readHand() {
                const hand = this.players[0].hand;
                if (hand.length === 0) { speaker.speak("æ‰‹ç‰Œæ˜¯ç©ºçš„", true); return; }
                const text = hand.map(t => getTileText(t)).join("ï¼Œ");
                speaker.speak(`ä½ æœ‰ ${hand.length} å¼µç‰Œï¼š${text}`, true);
            }

            readBoard() {
                if (this.board.length === 0) { 
                    speaker.speak("æ¡Œé¢ç›®å‰æ˜¯ç©ºçš„", true); 
                    return; 
                }
                
                speaker.speak(`æ¡Œä¸Šæœ‰ ${this.board.length} çµ„ç‰Œã€‚`, true);
                
                this.board.forEach((group, index) => {
                    const groupText = group.map(t => getTileText(t)).join("ã€");
                    speaker.speak(`ç¾¤çµ„ ${index + 1}ï¼š${groupText}`, false); // Queue subsequent groups
                });
            }

            announceDeckCount() { speaker.speak(`ç‰Œåº«å‰© ${this.deck.length} å¼µ`, true); }
            
            showMessage(msg) {
                const el = document.getElementById('message-toast');
                el.innerText = msg;
                el.classList.remove('hidden');
                el.classList.add('opacity-100');
                el.classList.add('scale-105');
                setTimeout(() => {
                    el.classList.remove('opacity-100');
                    el.classList.remove('scale-105');
                    setTimeout(() => el.classList.add('hidden'), 500);
                }, 2500);
            }

            highlightInvalidGroups(indices) {
                const groups = document.querySelectorAll('.board-group');
                indices.forEach(idx => {
                    if (groups[idx]) {
                        groups[idx].classList.add('invalid');
                        setTimeout(() => groups[idx].classList.remove('invalid'), 2000);
                    }
                });
            }

            showVictory(winner) {
                const modal = document.getElementById('victory-modal');
                const winnerText = document.getElementById('winner-text');
                const tbody = document.getElementById('score-table-body');
                
                let losersSum = 0;
                const scores = [];

                this.players.forEach(p => {
                    if (p.id !== winner.id) {
                        const handVal = this.calculateHandScore(p.hand);
                        losersSum += handVal;
                        scores.push({ name: p.name, handVal: handVal, score: -handVal });
                    }
                });

                scores.push({ name: winner.name, handVal: 0, score: losersSum });
                scores.sort((a,b) => b.score - a.score);

                winnerText.innerText = `ğŸ‰ ${winner.name} ç²å‹ï¼`;
                tbody.innerHTML = '';

                scores.forEach(s => {
                    const tr = document.createElement('tr');
                    tr.className = "border-b border-gray-200 last:border-0";
                    tr.innerHTML = `
                        <td class="py-2 pl-2 font-medium">${s.name}</td>
                        <td class="py-2 text-right text-gray-500">${s.handVal}</td>
                        <td class="py-2 text-right pr-2 font-bold ${s.score > 0 ? 'text-green-600' : 'text-red-600'}">${s.score > 0 ? '+'+s.score : s.score}</td>
                    `;
                    tbody.appendChild(tr);
                });

                modal.classList.remove('hidden');
                speaker.speak(`éŠæˆ²çµæŸï¼Œ${winner.name} ç²å‹ï¼`, true);
                setTimeout(() => modal.querySelector('button').focus(), 100);
            }

            render() {
                const currentPlayer = this.players[this.turn];
                const indicator = document.getElementById('turn-indicator');
                const iceStatus = document.getElementById('ice-status');
                
                if (this.isGlobalIceBroken) {
                    iceStatus.innerText = "å·²ç ´å†°";
                    iceStatus.className = "text-center text-xs text-green-600 font-bold mt-1";
                } else {
                    iceStatus.innerText = "å°šæœªç ´å†° (éœ€ 30 åˆ†)";
                    iceStatus.className = "text-center text-xs text-gray-500 font-mono mt-1";
                }

                if(currentPlayer.type === 'computer') {
                    indicator.innerText = `${currentPlayer.name} æ€è€ƒä¸­...`;
                    indicator.className = "mx-auto px-6 py-1.5 bg-gray-500 text-white rounded-full shadow-md text-sm font-bold tracking-wide transition-colors";
                } else {
                    indicator.innerText = "è¼ªåˆ°ä½ äº†ï¼";
                    indicator.className = "mx-auto px-6 py-1.5 bg-blue-600 text-white rounded-full shadow-md text-sm font-bold tracking-wide transition-colors animate-pulse";
                }
                
                document.getElementById('deck-count').innerText = this.deck.length;

                for(let i=2; i<=4; i++) {
                    const p = this.players[i-1];
                    const container = document.getElementById(`p${i}-cards`);
                    const countLabel = document.getElementById(`p${i}-count`);
                    const statusDiv = document.getElementById(`p${i}-status`);
                    
                    container.innerHTML = '';
                    const maxShow = Math.min(p.hand.length, 5); 
                    for(let k=0; k<maxShow; k++) {
                        const card = document.createElement('div');
                        card.className = 'opponent-card';
                        container.appendChild(card);
                    }
                    countLabel.innerText = `${p.hand.length}`;
                    
                    if(this.turn === i-1) {
                        statusDiv.className = "flex flex-col items-center bg-yellow-100 p-2 rounded shadow-md ring-2 ring-yellow-400 w-24 scale-105 transition-all opacity-100";
                    } else {
                        statusDiv.className = "flex flex-col items-center bg-white p-2 rounded shadow-sm opacity-60 w-24 transition-all";
                    }
                }

                const handContainer = document.getElementById('hand-area');
                handContainer.innerHTML = '';
                
                this.players[0].hand.forEach((tile, index) => {
                    const isSelected = this.selectedTiles.some(s => s.source === 'hand' && s.tileIndex === index);
                    const el = this.createTileElement(tile, 'hand', -1, index, isSelected);
                    handContainer.appendChild(el);
                });

                const boardContainer = document.getElementById('board-groups');
                boardContainer.innerHTML = '';
                this.board.forEach((group, groupIndex) => {
                    const groupEl = document.createElement('div');
                    groupEl.className = 'board-group';
                    if (this.players[this.turn].type === 'human') {
                        if (this.selectedTiles.length > 0) {
                            groupEl.setAttribute('role', 'button');
                            groupEl.setAttribute('aria-label', `ç§»å‹•åˆ°ç¾¤çµ„ ${groupIndex + 1}`);
                            groupEl.setAttribute('tabindex', '0'); 
                            groupEl.classList.add('game-focusable');
                            groupEl.onclick = () => this.handleAreaClick(groupIndex);
                            groupEl.onkeydown = (e) => { if(e.key === 'Enter') this.handleAreaClick(groupIndex); };
                            groupEl.classList.add('cursor-pointer', 'ring-2', 'ring-yellow-400', 'bg-white/10');
                        } else {
                            groupEl.setAttribute('role', 'list');
                        }
                    }
                    groupEl.setAttribute('data-label', `${groupIndex + 1}`);
                    
                    group.forEach((tile, tileIndex) => {
                        const isSelected = this.selectedTiles.some(s => s.source === 'board' && s.groupIndex === groupIndex && s.tileIndex === tileIndex);
                        const tileEl = this.createTileElement(tile, 'board', groupIndex, tileIndex, isSelected);
                        groupEl.appendChild(tileEl);
                    });
                    boardContainer.appendChild(groupEl);
                });
                
                const btnDraw = document.getElementById('btn-draw');
                const btnSubmit = document.getElementById('btn-submit');
                
                if (this.players[this.turn].type === 'computer') {
                    btnDraw.disabled = true;
                    btnSubmit.disabled = true;
                    btnDraw.classList.add('opacity-50', 'cursor-not-allowed');
                    btnSubmit.classList.add('opacity-50', 'cursor-not-allowed');
                } else {
                    btnDraw.disabled = false;
                    btnSubmit.disabled = false;
                    btnDraw.classList.remove('opacity-50', 'cursor-not-allowed');
                    btnSubmit.classList.remove('opacity-50', 'cursor-not-allowed');
                }

                if (this.selectedTiles.some(s => s.source === 'board')) {
                    handContainer.onclick = () => this.handleAreaClick('hand');
                    handContainer.classList.add('cursor-pointer', 'ring-4', 'ring-blue-400', 'bg-blue-800/50');
                } else {
                    handContainer.onclick = null;
                    handContainer.classList.remove('cursor-pointer', 'ring-4', 'ring-blue-400', 'bg-blue-800/50');
                }
            }

            createTileElement(tile, source, groupIndex, tileIndex, isSelected) {
                const el = document.createElement('button');
                el.className = `tile game-focusable ${COLOR_CLASSES[tile.color]} ${tile.isJoker ? 'joker' : ''} ${isSelected ? 'selected' : ''}`;
                el.tabIndex = 0; 
                
                if (tile.isJoker) {
                    el.innerHTML = `<span class="text-3xl text-gray-800">â˜º</span>`;
                } else {
                    el.innerHTML = `<span class="text-2xl">${tile.number}</span>`;
                }

                el.setAttribute('aria-label', `${isSelected?"å·²é¸ ":""}${getTileText(tile)}`);
                
                const playAudio = () => {
                    speaker.speak(getTileText(tile), true);
                };
                el.onmouseenter = playAudio;
                el.onfocus = playAudio;

                if (this.players[this.turn].type === 'human') {
                    el.onclick = (e) => {
                        e.stopPropagation();
                        this.handleTileClick(source, groupIndex, tileIndex, tile);
                    };
                } else {
                    el.classList.add('cursor-default');
                    el.removeAttribute('tabindex'); 
                }
                return el;
            }
        }

        const game = new RummikubGame();

    </script>
</body>
</html>